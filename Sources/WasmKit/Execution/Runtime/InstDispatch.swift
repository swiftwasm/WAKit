// This file is generated by Utilities/generate_inst_dispatch.swift
extension ExecutionState {
    @inline(__always)
    mutating func doExecute(_ instruction: Instruction, sp: inout Sp, pc: inout Pc, md: inout Md, ms: inout Ms) throws -> Bool {
        switch instruction {
        case .copyStack(let copyStackOperand):
            self.copyStack(sp: sp, copyStackOperand: copyStackOperand)
        case .globalGet(let globalGetOperand):
            try self.globalGet(sp: sp, globalGetOperand: globalGetOperand)
        case .globalSet(let globalSetOperand):
            try self.globalSet(sp: sp, globalSetOperand: globalSetOperand)
        case .call(let callOperand):
            try self.call(sp: &sp, pc: &pc, md: &md, ms: &ms, callOperand: callOperand)
            return false
        case .compilingCall(let compilingCallOperand):
            try self.compilingCall(sp: &sp, pc: &pc, compilingCallOperand: compilingCallOperand)
            return false
        case .internalCall(let internalCallOperand):
            try self.internalCall(sp: &sp, pc: &pc, internalCallOperand: internalCallOperand)
            return false
        case .callIndirect(let callIndirectOperand):
            try self.callIndirect(sp: &sp, pc: &pc, md: &md, ms: &ms, callIndirectOperand: callIndirectOperand)
            return false
        case .unreachable:
            try self.unreachable(sp: sp, pc: &pc)
            return true
        case .nop:
            try self.nop(sp: sp, pc: &pc)
            return true
        case .ifThen(let ifOperand):
            self.ifThen(sp: sp, pc: &pc, ifOperand: ifOperand)
            return true
        case .br(let offset):
            try self.br(sp: sp, pc: &pc, offset: offset)
            return true
        case .brIf(let brIfOperand):
            try self.brIf(sp: sp, pc: &pc, brIfOperand: brIfOperand)
            return true
        case .brIfNot(let brIfOperand):
            try self.brIfNot(sp: sp, pc: &pc, brIfOperand: brIfOperand)
            return true
        case .brTable(let brTableOperand):
            try self.brTable(sp: sp, pc: &pc, brTableOperand: brTableOperand)
            return true
        case .`return`:
            try self.`return`(sp: &sp, pc: &pc, md: &md, ms: &ms)
            return false
        case .endOfExecution:
            try self.endOfExecution(sp: &sp, pc: &pc)
            return false
        case .i32Load(let loadOperand):
            try self.i32Load(sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i64Load(let loadOperand):
            try self.i64Load(sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .f32Load(let loadOperand):
            try self.f32Load(sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .f64Load(let loadOperand):
            try self.f64Load(sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i32Load8S(let loadOperand):
            try self.i32Load8S(sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i32Load8U(let loadOperand):
            try self.i32Load8U(sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i32Load16S(let loadOperand):
            try self.i32Load16S(sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i32Load16U(let loadOperand):
            try self.i32Load16U(sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i64Load8S(let loadOperand):
            try self.i64Load8S(sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i64Load8U(let loadOperand):
            try self.i64Load8U(sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i64Load16S(let loadOperand):
            try self.i64Load16S(sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i64Load16U(let loadOperand):
            try self.i64Load16U(sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i64Load32S(let loadOperand):
            try self.i64Load32S(sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i64Load32U(let loadOperand):
            try self.i64Load32U(sp: sp, md: md, ms: ms, loadOperand: loadOperand)
        case .i32Store(let storeOperand):
            try self.i32Store(sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .i64Store(let storeOperand):
            try self.i64Store(sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .f32Store(let storeOperand):
            try self.f32Store(sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .f64Store(let storeOperand):
            try self.f64Store(sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .i32Store8(let storeOperand):
            try self.i32Store8(sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .i32Store16(let storeOperand):
            try self.i32Store16(sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .i64Store8(let storeOperand):
            try self.i64Store8(sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .i64Store16(let storeOperand):
            try self.i64Store16(sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .i64Store32(let storeOperand):
            try self.i64Store32(sp: sp, md: md, ms: ms, storeOperand: storeOperand)
        case .memorySize(let memorySizeOperand):
            self.memorySize(sp: sp, memorySizeOperand: memorySizeOperand)
        case .memoryGrow(let memoryGrowOperand):
            try self.memoryGrow(sp: sp, md: &md, ms: &ms, memoryGrowOperand: memoryGrowOperand)
        case .memoryInit(let memoryInitOperand):
            try self.memoryInit(sp: sp, memoryInitOperand: memoryInitOperand)
        case .memoryDataDrop(let dataIndex):
            self.memoryDataDrop(sp: sp, dataIndex: dataIndex)
        case .memoryCopy(let memoryCopyOperand):
            try self.memoryCopy(sp: sp, memoryCopyOperand: memoryCopyOperand)
        case .memoryFill(let memoryFillOperand):
            try self.memoryFill(sp: sp, memoryFillOperand: memoryFillOperand)
        case .numericConst(let constOperand):
            self.numericConst(sp: sp, constOperand: constOperand)
        case .numericFloatUnary(let floatUnary, let unaryOperand):
            self.numericFloatUnary(sp: sp, floatUnary: floatUnary, unaryOperand: unaryOperand)
        case .numericIntBinary(let intBinary, let binaryOperand):
            try self.numericIntBinary(sp: sp, intBinary: intBinary, binaryOperand: binaryOperand)
        case .numericFloatBinary(let floatBinary, let binaryOperand):
            self.numericFloatBinary(sp: sp, floatBinary: floatBinary, binaryOperand: binaryOperand)
        case .numericConversion(let conversion, let unaryOperand):
            try self.numericConversion(sp: sp, conversion: conversion, unaryOperand: unaryOperand)
        case .i32Add(let binaryOperand):
            self.i32Add(sp: sp, binaryOperand: binaryOperand)
        case .i64Add(let binaryOperand):
            self.i64Add(sp: sp, binaryOperand: binaryOperand)
        case .i32Sub(let binaryOperand):
            self.i32Sub(sp: sp, binaryOperand: binaryOperand)
        case .i64Sub(let binaryOperand):
            self.i64Sub(sp: sp, binaryOperand: binaryOperand)
        case .i32Mul(let binaryOperand):
            self.i32Mul(sp: sp, binaryOperand: binaryOperand)
        case .i64Mul(let binaryOperand):
            self.i64Mul(sp: sp, binaryOperand: binaryOperand)
        case .i32And(let binaryOperand):
            self.i32And(sp: sp, binaryOperand: binaryOperand)
        case .i64And(let binaryOperand):
            self.i64And(sp: sp, binaryOperand: binaryOperand)
        case .i32Or(let binaryOperand):
            self.i32Or(sp: sp, binaryOperand: binaryOperand)
        case .i64Or(let binaryOperand):
            self.i64Or(sp: sp, binaryOperand: binaryOperand)
        case .i32Xor(let binaryOperand):
            self.i32Xor(sp: sp, binaryOperand: binaryOperand)
        case .i64Xor(let binaryOperand):
            self.i64Xor(sp: sp, binaryOperand: binaryOperand)
        case .i32Shl(let binaryOperand):
            self.i32Shl(sp: sp, binaryOperand: binaryOperand)
        case .i64Shl(let binaryOperand):
            self.i64Shl(sp: sp, binaryOperand: binaryOperand)
        case .i32ShrS(let binaryOperand):
            self.i32ShrS(sp: sp, binaryOperand: binaryOperand)
        case .i64ShrS(let binaryOperand):
            self.i64ShrS(sp: sp, binaryOperand: binaryOperand)
        case .i32ShrU(let binaryOperand):
            self.i32ShrU(sp: sp, binaryOperand: binaryOperand)
        case .i64ShrU(let binaryOperand):
            self.i64ShrU(sp: sp, binaryOperand: binaryOperand)
        case .i32Rotl(let binaryOperand):
            self.i32Rotl(sp: sp, binaryOperand: binaryOperand)
        case .i64Rotl(let binaryOperand):
            self.i64Rotl(sp: sp, binaryOperand: binaryOperand)
        case .i32Rotr(let binaryOperand):
            self.i32Rotr(sp: sp, binaryOperand: binaryOperand)
        case .i64Rotr(let binaryOperand):
            self.i64Rotr(sp: sp, binaryOperand: binaryOperand)
        case .i32Eq(let binaryOperand):
            self.i32Eq(sp: sp, binaryOperand: binaryOperand)
        case .i64Eq(let binaryOperand):
            self.i64Eq(sp: sp, binaryOperand: binaryOperand)
        case .i32Ne(let binaryOperand):
            self.i32Ne(sp: sp, binaryOperand: binaryOperand)
        case .i64Ne(let binaryOperand):
            self.i64Ne(sp: sp, binaryOperand: binaryOperand)
        case .i32LtS(let binaryOperand):
            self.i32LtS(sp: sp, binaryOperand: binaryOperand)
        case .i64LtS(let binaryOperand):
            self.i64LtS(sp: sp, binaryOperand: binaryOperand)
        case .i32LtU(let binaryOperand):
            self.i32LtU(sp: sp, binaryOperand: binaryOperand)
        case .i64LtU(let binaryOperand):
            self.i64LtU(sp: sp, binaryOperand: binaryOperand)
        case .i32GtS(let binaryOperand):
            self.i32GtS(sp: sp, binaryOperand: binaryOperand)
        case .i64GtS(let binaryOperand):
            self.i64GtS(sp: sp, binaryOperand: binaryOperand)
        case .i32GtU(let binaryOperand):
            self.i32GtU(sp: sp, binaryOperand: binaryOperand)
        case .i64GtU(let binaryOperand):
            self.i64GtU(sp: sp, binaryOperand: binaryOperand)
        case .i32LeS(let binaryOperand):
            self.i32LeS(sp: sp, binaryOperand: binaryOperand)
        case .i64LeS(let binaryOperand):
            self.i64LeS(sp: sp, binaryOperand: binaryOperand)
        case .i32LeU(let binaryOperand):
            self.i32LeU(sp: sp, binaryOperand: binaryOperand)
        case .i64LeU(let binaryOperand):
            self.i64LeU(sp: sp, binaryOperand: binaryOperand)
        case .i32GeS(let binaryOperand):
            self.i32GeS(sp: sp, binaryOperand: binaryOperand)
        case .i64GeS(let binaryOperand):
            self.i64GeS(sp: sp, binaryOperand: binaryOperand)
        case .i32GeU(let binaryOperand):
            self.i32GeU(sp: sp, binaryOperand: binaryOperand)
        case .i64GeU(let binaryOperand):
            self.i64GeU(sp: sp, binaryOperand: binaryOperand)
        case .i32Clz(let unaryOperand):
            self.i32Clz(sp: sp, unaryOperand: unaryOperand)
        case .i64Clz(let unaryOperand):
            self.i64Clz(sp: sp, unaryOperand: unaryOperand)
        case .i32Ctz(let unaryOperand):
            self.i32Ctz(sp: sp, unaryOperand: unaryOperand)
        case .i64Ctz(let unaryOperand):
            self.i64Ctz(sp: sp, unaryOperand: unaryOperand)
        case .i32Popcnt(let unaryOperand):
            self.i32Popcnt(sp: sp, unaryOperand: unaryOperand)
        case .i64Popcnt(let unaryOperand):
            self.i64Popcnt(sp: sp, unaryOperand: unaryOperand)
        case .i32Eqz(let unaryOperand):
            self.i32Eqz(sp: sp, unaryOperand: unaryOperand)
        case .i64Eqz(let unaryOperand):
            self.i64Eqz(sp: sp, unaryOperand: unaryOperand)
        case .f32Add(let binaryOperand):
            self.f32Add(sp: sp, binaryOperand: binaryOperand)
        case .f64Add(let binaryOperand):
            self.f64Add(sp: sp, binaryOperand: binaryOperand)
        case .f32Sub(let binaryOperand):
            self.f32Sub(sp: sp, binaryOperand: binaryOperand)
        case .f64Sub(let binaryOperand):
            self.f64Sub(sp: sp, binaryOperand: binaryOperand)
        case .f32Mul(let binaryOperand):
            self.f32Mul(sp: sp, binaryOperand: binaryOperand)
        case .f64Mul(let binaryOperand):
            self.f64Mul(sp: sp, binaryOperand: binaryOperand)
        case .f32Div(let binaryOperand):
            self.f32Div(sp: sp, binaryOperand: binaryOperand)
        case .f64Div(let binaryOperand):
            self.f64Div(sp: sp, binaryOperand: binaryOperand)
        case .f32Eq(let binaryOperand):
            self.f32Eq(sp: sp, binaryOperand: binaryOperand)
        case .f64Eq(let binaryOperand):
            self.f64Eq(sp: sp, binaryOperand: binaryOperand)
        case .f32Ne(let binaryOperand):
            self.f32Ne(sp: sp, binaryOperand: binaryOperand)
        case .f64Ne(let binaryOperand):
            self.f64Ne(sp: sp, binaryOperand: binaryOperand)
        case .select(let selectOperand):
            try self.select(sp: sp, selectOperand: selectOperand)
        case .refNull(let refNullOperand):
            self.refNull(sp: sp, refNullOperand: refNullOperand)
        case .refIsNull(let refIsNullOperand):
            self.refIsNull(sp: sp, refIsNullOperand: refIsNullOperand)
        case .refFunc(let refFuncOperand):
            self.refFunc(sp: sp, refFuncOperand: refFuncOperand)
        case .tableGet(let tableGetOperand):
            try self.tableGet(sp: sp, tableGetOperand: tableGetOperand)
        case .tableSet(let tableSetOperand):
            try self.tableSet(sp: sp, tableSetOperand: tableSetOperand)
        case .tableSize(let tableSizeOperand):
            self.tableSize(sp: sp, tableSizeOperand: tableSizeOperand)
        case .tableGrow(let tableGrowOperand):
            try self.tableGrow(sp: sp, tableGrowOperand: tableGrowOperand)
        case .tableFill(let tableFillOperand):
            try self.tableFill(sp: sp, tableFillOperand: tableFillOperand)
        case .tableCopy(let tableCopyOperand):
            try self.tableCopy(sp: sp, tableCopyOperand: tableCopyOperand)
        case .tableInit(let tableInitOperand):
            try self.tableInit(sp: sp, tableInitOperand: tableInitOperand)
        case .tableElementDrop(let elementIndex):
            self.tableElementDrop(sp: sp, elementIndex: elementIndex)
        case .onEnter(let onEnterOperand):
            self.onEnter(sp: sp, onEnterOperand: onEnterOperand)
        case .onExit(let onExitOperand):
            self.onExit(sp: sp, onExitOperand: onExitOperand)
        }
        pc += 1
        return true
    }
}

extension Instruction {
    var name: String {
        switch self {
        case .copyStack: return "copyStack"
        case .globalGet: return "globalGet"
        case .globalSet: return "globalSet"
        case .call: return "call"
        case .compilingCall: return "compilingCall"
        case .internalCall: return "internalCall"
        case .callIndirect: return "callIndirect"
        case .unreachable: return "unreachable"
        case .nop: return "nop"
        case .ifThen: return "ifThen"
        case .br: return "br"
        case .brIf: return "brIf"
        case .brIfNot: return "brIfNot"
        case .brTable: return "brTable"
        case .`return`: return "`return`"
        case .endOfExecution: return "endOfExecution"
        case .i32Load: return "i32Load"
        case .i64Load: return "i64Load"
        case .f32Load: return "f32Load"
        case .f64Load: return "f64Load"
        case .i32Load8S: return "i32Load8S"
        case .i32Load8U: return "i32Load8U"
        case .i32Load16S: return "i32Load16S"
        case .i32Load16U: return "i32Load16U"
        case .i64Load8S: return "i64Load8S"
        case .i64Load8U: return "i64Load8U"
        case .i64Load16S: return "i64Load16S"
        case .i64Load16U: return "i64Load16U"
        case .i64Load32S: return "i64Load32S"
        case .i64Load32U: return "i64Load32U"
        case .i32Store: return "i32Store"
        case .i64Store: return "i64Store"
        case .f32Store: return "f32Store"
        case .f64Store: return "f64Store"
        case .i32Store8: return "i32Store8"
        case .i32Store16: return "i32Store16"
        case .i64Store8: return "i64Store8"
        case .i64Store16: return "i64Store16"
        case .i64Store32: return "i64Store32"
        case .memorySize: return "memorySize"
        case .memoryGrow: return "memoryGrow"
        case .memoryInit: return "memoryInit"
        case .memoryDataDrop: return "memoryDataDrop"
        case .memoryCopy: return "memoryCopy"
        case .memoryFill: return "memoryFill"
        case .numericConst: return "numericConst"
        case .numericFloatUnary: return "numericFloatUnary"
        case .numericIntBinary: return "numericIntBinary"
        case .numericFloatBinary: return "numericFloatBinary"
        case .numericConversion: return "numericConversion"
        case .i32Add: return "i32Add"
        case .i64Add: return "i64Add"
        case .i32Sub: return "i32Sub"
        case .i64Sub: return "i64Sub"
        case .i32Mul: return "i32Mul"
        case .i64Mul: return "i64Mul"
        case .i32And: return "i32And"
        case .i64And: return "i64And"
        case .i32Or: return "i32Or"
        case .i64Or: return "i64Or"
        case .i32Xor: return "i32Xor"
        case .i64Xor: return "i64Xor"
        case .i32Shl: return "i32Shl"
        case .i64Shl: return "i64Shl"
        case .i32ShrS: return "i32ShrS"
        case .i64ShrS: return "i64ShrS"
        case .i32ShrU: return "i32ShrU"
        case .i64ShrU: return "i64ShrU"
        case .i32Rotl: return "i32Rotl"
        case .i64Rotl: return "i64Rotl"
        case .i32Rotr: return "i32Rotr"
        case .i64Rotr: return "i64Rotr"
        case .i32Eq: return "i32Eq"
        case .i64Eq: return "i64Eq"
        case .i32Ne: return "i32Ne"
        case .i64Ne: return "i64Ne"
        case .i32LtS: return "i32LtS"
        case .i64LtS: return "i64LtS"
        case .i32LtU: return "i32LtU"
        case .i64LtU: return "i64LtU"
        case .i32GtS: return "i32GtS"
        case .i64GtS: return "i64GtS"
        case .i32GtU: return "i32GtU"
        case .i64GtU: return "i64GtU"
        case .i32LeS: return "i32LeS"
        case .i64LeS: return "i64LeS"
        case .i32LeU: return "i32LeU"
        case .i64LeU: return "i64LeU"
        case .i32GeS: return "i32GeS"
        case .i64GeS: return "i64GeS"
        case .i32GeU: return "i32GeU"
        case .i64GeU: return "i64GeU"
        case .i32Clz: return "i32Clz"
        case .i64Clz: return "i64Clz"
        case .i32Ctz: return "i32Ctz"
        case .i64Ctz: return "i64Ctz"
        case .i32Popcnt: return "i32Popcnt"
        case .i64Popcnt: return "i64Popcnt"
        case .i32Eqz: return "i32Eqz"
        case .i64Eqz: return "i64Eqz"
        case .f32Add: return "f32Add"
        case .f64Add: return "f64Add"
        case .f32Sub: return "f32Sub"
        case .f64Sub: return "f64Sub"
        case .f32Mul: return "f32Mul"
        case .f64Mul: return "f64Mul"
        case .f32Div: return "f32Div"
        case .f64Div: return "f64Div"
        case .f32Eq: return "f32Eq"
        case .f64Eq: return "f64Eq"
        case .f32Ne: return "f32Ne"
        case .f64Ne: return "f64Ne"
        case .select: return "select"
        case .refNull: return "refNull"
        case .refIsNull: return "refIsNull"
        case .refFunc: return "refFunc"
        case .tableGet: return "tableGet"
        case .tableSet: return "tableSet"
        case .tableSize: return "tableSize"
        case .tableGrow: return "tableGrow"
        case .tableFill: return "tableFill"
        case .tableCopy: return "tableCopy"
        case .tableInit: return "tableInit"
        case .tableElementDrop: return "tableElementDrop"
        case .onEnter: return "onEnter"
        case .onExit: return "onExit"
        }
    }
}


extension ExecutionState {
    mutating func i32Add(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].add(sp[i32: binaryOperand.rhs])
    }
    mutating func i64Add(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i64: binaryOperand.result] = sp[i64: binaryOperand.lhs].add(sp[i64: binaryOperand.rhs])
    }
    mutating func i32Sub(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].sub(sp[i32: binaryOperand.rhs])
    }
    mutating func i64Sub(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i64: binaryOperand.result] = sp[i64: binaryOperand.lhs].sub(sp[i64: binaryOperand.rhs])
    }
    mutating func i32Mul(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].mul(sp[i32: binaryOperand.rhs])
    }
    mutating func i64Mul(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i64: binaryOperand.result] = sp[i64: binaryOperand.lhs].mul(sp[i64: binaryOperand.rhs])
    }
    mutating func i32And(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].and(sp[i32: binaryOperand.rhs])
    }
    mutating func i64And(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i64: binaryOperand.result] = sp[i64: binaryOperand.lhs].and(sp[i64: binaryOperand.rhs])
    }
    mutating func i32Or(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].or(sp[i32: binaryOperand.rhs])
    }
    mutating func i64Or(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i64: binaryOperand.result] = sp[i64: binaryOperand.lhs].or(sp[i64: binaryOperand.rhs])
    }
    mutating func i32Xor(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].xor(sp[i32: binaryOperand.rhs])
    }
    mutating func i64Xor(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i64: binaryOperand.result] = sp[i64: binaryOperand.lhs].xor(sp[i64: binaryOperand.rhs])
    }
    mutating func i32Shl(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].shl(sp[i32: binaryOperand.rhs])
    }
    mutating func i64Shl(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i64: binaryOperand.result] = sp[i64: binaryOperand.lhs].shl(sp[i64: binaryOperand.rhs])
    }
    mutating func i32ShrS(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].shrs(sp[i32: binaryOperand.rhs])
    }
    mutating func i64ShrS(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i64: binaryOperand.result] = sp[i64: binaryOperand.lhs].shrs(sp[i64: binaryOperand.rhs])
    }
    mutating func i32ShrU(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].shru(sp[i32: binaryOperand.rhs])
    }
    mutating func i64ShrU(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i64: binaryOperand.result] = sp[i64: binaryOperand.lhs].shru(sp[i64: binaryOperand.rhs])
    }
    mutating func i32Rotl(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].rotl(sp[i32: binaryOperand.rhs])
    }
    mutating func i64Rotl(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i64: binaryOperand.result] = sp[i64: binaryOperand.lhs].rotl(sp[i64: binaryOperand.rhs])
    }
    mutating func i32Rotr(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].rotr(sp[i32: binaryOperand.rhs])
    }
    mutating func i64Rotr(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i64: binaryOperand.result] = sp[i64: binaryOperand.lhs].rotr(sp[i64: binaryOperand.rhs])
    }
    mutating func i32Eq(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].eq(sp[i32: binaryOperand.rhs])
    }
    mutating func i64Eq(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i64: binaryOperand.lhs].eq(sp[i64: binaryOperand.rhs])
    }
    mutating func i32Ne(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].ne(sp[i32: binaryOperand.rhs])
    }
    mutating func i64Ne(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i64: binaryOperand.lhs].ne(sp[i64: binaryOperand.rhs])
    }
    mutating func i32LtS(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].lts(sp[i32: binaryOperand.rhs])
    }
    mutating func i64LtS(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i64: binaryOperand.lhs].lts(sp[i64: binaryOperand.rhs])
    }
    mutating func i32LtU(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].ltu(sp[i32: binaryOperand.rhs])
    }
    mutating func i64LtU(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i64: binaryOperand.lhs].ltu(sp[i64: binaryOperand.rhs])
    }
    mutating func i32GtS(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].gts(sp[i32: binaryOperand.rhs])
    }
    mutating func i64GtS(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i64: binaryOperand.lhs].gts(sp[i64: binaryOperand.rhs])
    }
    mutating func i32GtU(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].gtu(sp[i32: binaryOperand.rhs])
    }
    mutating func i64GtU(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i64: binaryOperand.lhs].gtu(sp[i64: binaryOperand.rhs])
    }
    mutating func i32LeS(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].les(sp[i32: binaryOperand.rhs])
    }
    mutating func i64LeS(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i64: binaryOperand.lhs].les(sp[i64: binaryOperand.rhs])
    }
    mutating func i32LeU(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].leu(sp[i32: binaryOperand.rhs])
    }
    mutating func i64LeU(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i64: binaryOperand.lhs].leu(sp[i64: binaryOperand.rhs])
    }
    mutating func i32GeS(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].ges(sp[i32: binaryOperand.rhs])
    }
    mutating func i64GeS(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i64: binaryOperand.lhs].ges(sp[i64: binaryOperand.rhs])
    }
    mutating func i32GeU(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i32: binaryOperand.lhs].geu(sp[i32: binaryOperand.rhs])
    }
    mutating func i64GeU(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[i64: binaryOperand.lhs].geu(sp[i64: binaryOperand.rhs])
    }
    mutating func f32Add(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[f32: binaryOperand.result] = sp[f32: binaryOperand.lhs].add(sp[f32: binaryOperand.rhs])
    }
    mutating func f64Add(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[f64: binaryOperand.result] = sp[f64: binaryOperand.lhs].add(sp[f64: binaryOperand.rhs])
    }
    mutating func f32Sub(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[f32: binaryOperand.result] = sp[f32: binaryOperand.lhs].sub(sp[f32: binaryOperand.rhs])
    }
    mutating func f64Sub(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[f64: binaryOperand.result] = sp[f64: binaryOperand.lhs].sub(sp[f64: binaryOperand.rhs])
    }
    mutating func f32Mul(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[f32: binaryOperand.result] = sp[f32: binaryOperand.lhs].mul(sp[f32: binaryOperand.rhs])
    }
    mutating func f64Mul(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[f64: binaryOperand.result] = sp[f64: binaryOperand.lhs].mul(sp[f64: binaryOperand.rhs])
    }
    mutating func f32Div(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[f32: binaryOperand.result] = sp[f32: binaryOperand.lhs].div(sp[f32: binaryOperand.rhs])
    }
    mutating func f64Div(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[f64: binaryOperand.result] = sp[f64: binaryOperand.lhs].div(sp[f64: binaryOperand.rhs])
    }
    mutating func f32Eq(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[f32: binaryOperand.lhs].eq(sp[f32: binaryOperand.rhs])
    }
    mutating func f64Eq(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[f64: binaryOperand.lhs].eq(sp[f64: binaryOperand.rhs])
    }
    mutating func f32Ne(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[f32: binaryOperand.lhs].ne(sp[f32: binaryOperand.rhs])
    }
    mutating func f64Ne(sp: Sp, binaryOperand: Instruction.BinaryOperand) {
        sp[i32: binaryOperand.result] = sp[f64: binaryOperand.lhs].ne(sp[f64: binaryOperand.rhs])
    }
    mutating func i32Clz(sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[i32: unaryOperand.result] = sp[i32: unaryOperand.input].clz
    }
    mutating func i64Clz(sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[i64: unaryOperand.result] = sp[i64: unaryOperand.input].clz
    }
    mutating func i32Ctz(sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[i32: unaryOperand.result] = sp[i32: unaryOperand.input].ctz
    }
    mutating func i64Ctz(sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[i64: unaryOperand.result] = sp[i64: unaryOperand.input].ctz
    }
    mutating func i32Popcnt(sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[i32: unaryOperand.result] = sp[i32: unaryOperand.input].popcnt
    }
    mutating func i64Popcnt(sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[i64: unaryOperand.result] = sp[i64: unaryOperand.input].popcnt
    }
    mutating func i32Eqz(sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[i32: unaryOperand.result] = sp[i32: unaryOperand.input].eqz
    }
    mutating func i64Eqz(sp: Sp, unaryOperand: Instruction.UnaryOperand) {
        sp[i32: unaryOperand.result] = sp[i64: unaryOperand.input].eqz
    }
    mutating func i32Load(sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt32.self, castToValue: { .i32($0) })
    }
    mutating func i64Load(sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt64.self, castToValue: { .i64($0) })
    }
    mutating func f32Load(sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt32.self, castToValue: { .rawF32($0) })
    }
    mutating func f64Load(sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt64.self, castToValue: { .rawF64($0) })
    }
    mutating func i32Load8S(sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: Int8.self, castToValue: { .init(signed: Int32($0)) })
    }
    mutating func i32Load8U(sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt8.self, castToValue: { .i32(UInt32($0)) })
    }
    mutating func i32Load16S(sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: Int16.self, castToValue: { .init(signed: Int32($0)) })
    }
    mutating func i32Load16U(sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt16.self, castToValue: { .i32(UInt32($0)) })
    }
    mutating func i64Load8S(sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: Int8.self, castToValue: { .init(signed: Int64($0)) })
    }
    mutating func i64Load8U(sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt8.self, castToValue: { .i64(UInt64($0)) })
    }
    mutating func i64Load16S(sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: Int16.self, castToValue: { .init(signed: Int64($0)) })
    }
    mutating func i64Load16U(sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt16.self, castToValue: { .i64(UInt64($0)) })
    }
    mutating func i64Load32S(sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: Int32.self, castToValue: { .init(signed: Int64($0)) })
    }
    mutating func i64Load32U(sp: Sp, md: Md, ms: Ms, loadOperand: Instruction.LoadOperand) throws {
        try memoryLoad(sp: sp, md: md, ms: ms, loadOperand: loadOperand, loadAs: UInt32.self, castToValue: { .i64(UInt64($0)) })
    }
    mutating func i32Store(sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { $0.i32 })
    }
    mutating func i64Store(sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { $0.i64 })
    }
    mutating func f32Store(sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { $0.rawF32 })
    }
    mutating func f64Store(sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { $0.rawF64 })
    }
    mutating func i32Store8(sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { UInt8(truncatingIfNeeded: $0.i32) })
    }
    mutating func i32Store16(sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { UInt16(truncatingIfNeeded: $0.i32) })
    }
    mutating func i64Store8(sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { UInt8(truncatingIfNeeded: $0.i64) })
    }
    mutating func i64Store16(sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { UInt16(truncatingIfNeeded: $0.i64) })
    }
    mutating func i64Store32(sp: Sp, md: Md, ms: Ms, storeOperand: Instruction.StoreOperand) throws {
        try memoryStore(sp: sp, md: md, ms: ms, storeOperand: storeOperand, castFromValue: { UInt32(truncatingIfNeeded: $0.i64) })
    }
}
