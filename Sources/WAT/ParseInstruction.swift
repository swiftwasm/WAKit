// swift-format-ignore-file
//// Automatically generated by Utilities/Sources/WasmGen.swift
//// DO NOT EDIT DIRECTLY

import WasmParser
import WasmTypes

/// Parses a text instruction, consuming immediate tokens as necessary.
/// - Parameters:
///   - keyword: The keyword of the instruction.
///   - expressionParser: The expression parser.
/// - Returns: A closure that invokes the corresponding visitor method. Nil if the keyword is not recognized.
///
/// Note: The returned closure does not consume any tokens.
func parseTextInstruction<V: InstructionVisitor>(keyword: String, expressionParser: inout ExpressionParser<V>, wat: inout Wat) throws -> ((inout V) throws -> Void)? {
    switch keyword {
    case "unreachable": return { return try $0.visitUnreachable() }
    case "nop": return { return try $0.visitNop() }
    case "block":
        let (blockType) = try expressionParser.visitBlock(wat: &wat)
        return { return try $0.visitBlock(blockType: blockType) }
    case "loop":
        let (blockType) = try expressionParser.visitLoop(wat: &wat)
        return { return try $0.visitLoop(blockType: blockType) }
    case "if":
        let (blockType) = try expressionParser.visitIf(wat: &wat)
        return { return try $0.visitIf(blockType: blockType) }
    case "else": return { return try $0.visitElse() }
    case "end": return { return try $0.visitEnd() }
    case "br":
        let (relativeDepth) = try expressionParser.visitBr(wat: &wat)
        return { return try $0.visitBr(relativeDepth: relativeDepth) }
    case "br_if":
        let (relativeDepth) = try expressionParser.visitBrIf(wat: &wat)
        return { return try $0.visitBrIf(relativeDepth: relativeDepth) }
    case "br_table":
        let (targets) = try expressionParser.visitBrTable(wat: &wat)
        return { return try $0.visitBrTable(targets: targets) }
    case "return": return { return try $0.visitReturn() }
    case "call":
        let (functionIndex) = try expressionParser.visitCall(wat: &wat)
        return { return try $0.visitCall(functionIndex: functionIndex) }
    case "call_indirect":
        let (typeIndex, tableIndex) = try expressionParser.visitCallIndirect(wat: &wat)
        return { return try $0.visitCallIndirect(typeIndex: typeIndex, tableIndex: tableIndex) }
    case "drop": return { return try $0.visitDrop() }
    case "select": return { return try $0.visitSelect() }
    case "local.get":
        let (localIndex) = try expressionParser.visitLocalGet(wat: &wat)
        return { return try $0.visitLocalGet(localIndex: localIndex) }
    case "local.set":
        let (localIndex) = try expressionParser.visitLocalSet(wat: &wat)
        return { return try $0.visitLocalSet(localIndex: localIndex) }
    case "local.tee":
        let (localIndex) = try expressionParser.visitLocalTee(wat: &wat)
        return { return try $0.visitLocalTee(localIndex: localIndex) }
    case "global.get":
        let (globalIndex) = try expressionParser.visitGlobalGet(wat: &wat)
        return { return try $0.visitGlobalGet(globalIndex: globalIndex) }
    case "global.set":
        let (globalIndex) = try expressionParser.visitGlobalSet(wat: &wat)
        return { return try $0.visitGlobalSet(globalIndex: globalIndex) }
    case "i32.load":
        let (memarg) = try expressionParser.visitI32Load(wat: &wat)
        return { return try $0.visitI32Load(memarg: memarg) }
    case "i64.load":
        let (memarg) = try expressionParser.visitI64Load(wat: &wat)
        return { return try $0.visitI64Load(memarg: memarg) }
    case "f32.load":
        let (memarg) = try expressionParser.visitF32Load(wat: &wat)
        return { return try $0.visitF32Load(memarg: memarg) }
    case "f64.load":
        let (memarg) = try expressionParser.visitF64Load(wat: &wat)
        return { return try $0.visitF64Load(memarg: memarg) }
    case "i32.load8_s":
        let (memarg) = try expressionParser.visitI32Load8S(wat: &wat)
        return { return try $0.visitI32Load8S(memarg: memarg) }
    case "i32.load8_u":
        let (memarg) = try expressionParser.visitI32Load8U(wat: &wat)
        return { return try $0.visitI32Load8U(memarg: memarg) }
    case "i32.load16_s":
        let (memarg) = try expressionParser.visitI32Load16S(wat: &wat)
        return { return try $0.visitI32Load16S(memarg: memarg) }
    case "i32.load16_u":
        let (memarg) = try expressionParser.visitI32Load16U(wat: &wat)
        return { return try $0.visitI32Load16U(memarg: memarg) }
    case "i64.load8_s":
        let (memarg) = try expressionParser.visitI64Load8S(wat: &wat)
        return { return try $0.visitI64Load8S(memarg: memarg) }
    case "i64.load8_u":
        let (memarg) = try expressionParser.visitI64Load8U(wat: &wat)
        return { return try $0.visitI64Load8U(memarg: memarg) }
    case "i64.load16_s":
        let (memarg) = try expressionParser.visitI64Load16S(wat: &wat)
        return { return try $0.visitI64Load16S(memarg: memarg) }
    case "i64.load16_u":
        let (memarg) = try expressionParser.visitI64Load16U(wat: &wat)
        return { return try $0.visitI64Load16U(memarg: memarg) }
    case "i64.load32_s":
        let (memarg) = try expressionParser.visitI64Load32S(wat: &wat)
        return { return try $0.visitI64Load32S(memarg: memarg) }
    case "i64.load32_u":
        let (memarg) = try expressionParser.visitI64Load32U(wat: &wat)
        return { return try $0.visitI64Load32U(memarg: memarg) }
    case "i32.store":
        let (memarg) = try expressionParser.visitI32Store(wat: &wat)
        return { return try $0.visitI32Store(memarg: memarg) }
    case "i64.store":
        let (memarg) = try expressionParser.visitI64Store(wat: &wat)
        return { return try $0.visitI64Store(memarg: memarg) }
    case "f32.store":
        let (memarg) = try expressionParser.visitF32Store(wat: &wat)
        return { return try $0.visitF32Store(memarg: memarg) }
    case "f64.store":
        let (memarg) = try expressionParser.visitF64Store(wat: &wat)
        return { return try $0.visitF64Store(memarg: memarg) }
    case "i32.store8":
        let (memarg) = try expressionParser.visitI32Store8(wat: &wat)
        return { return try $0.visitI32Store8(memarg: memarg) }
    case "i32.store16":
        let (memarg) = try expressionParser.visitI32Store16(wat: &wat)
        return { return try $0.visitI32Store16(memarg: memarg) }
    case "i64.store8":
        let (memarg) = try expressionParser.visitI64Store8(wat: &wat)
        return { return try $0.visitI64Store8(memarg: memarg) }
    case "i64.store16":
        let (memarg) = try expressionParser.visitI64Store16(wat: &wat)
        return { return try $0.visitI64Store16(memarg: memarg) }
    case "i64.store32":
        let (memarg) = try expressionParser.visitI64Store32(wat: &wat)
        return { return try $0.visitI64Store32(memarg: memarg) }
    case "memory.size":
        let (memory) = try expressionParser.visitMemorySize(wat: &wat)
        return { return try $0.visitMemorySize(memory: memory) }
    case "memory.grow":
        let (memory) = try expressionParser.visitMemoryGrow(wat: &wat)
        return { return try $0.visitMemoryGrow(memory: memory) }
    case "i32.const":
        let (value) = try expressionParser.visitI32Const(wat: &wat)
        return { return try $0.visitI32Const(value: value) }
    case "i64.const":
        let (value) = try expressionParser.visitI64Const(wat: &wat)
        return { return try $0.visitI64Const(value: value) }
    case "f32.const":
        let (value) = try expressionParser.visitF32Const(wat: &wat)
        return { return try $0.visitF32Const(value: value) }
    case "f64.const":
        let (value) = try expressionParser.visitF64Const(wat: &wat)
        return { return try $0.visitF64Const(value: value) }
    case "ref.null":
        let (type) = try expressionParser.visitRefNull(wat: &wat)
        return { return try $0.visitRefNull(type: type) }
    case "ref.is_null": return { return try $0.visitRefIsNull() }
    case "ref.func":
        let (functionIndex) = try expressionParser.visitRefFunc(wat: &wat)
        return { return try $0.visitRefFunc(functionIndex: functionIndex) }
    case "i32.eqz": return { return try $0.visitI32Eqz() }
    case "i32.eq": return { return try $0.visitI32Eq() }
    case "i32.ne": return { return try $0.visitI32Ne() }
    case "i32.lt_s": return { return try $0.visitI32LtS() }
    case "i32.lt_u": return { return try $0.visitI32LtU() }
    case "i32.gt_s": return { return try $0.visitI32GtS() }
    case "i32.gt_u": return { return try $0.visitI32GtU() }
    case "i32.le_s": return { return try $0.visitI32LeS() }
    case "i32.le_u": return { return try $0.visitI32LeU() }
    case "i32.ge_s": return { return try $0.visitI32GeS() }
    case "i32.ge_u": return { return try $0.visitI32GeU() }
    case "i64.eqz": return { return try $0.visitI64Eqz() }
    case "i64.eq": return { return try $0.visitI64Eq() }
    case "i64.ne": return { return try $0.visitI64Ne() }
    case "i64.lt_s": return { return try $0.visitI64LtS() }
    case "i64.lt_u": return { return try $0.visitI64LtU() }
    case "i64.gt_s": return { return try $0.visitI64GtS() }
    case "i64.gt_u": return { return try $0.visitI64GtU() }
    case "i64.le_s": return { return try $0.visitI64LeS() }
    case "i64.le_u": return { return try $0.visitI64LeU() }
    case "i64.ge_s": return { return try $0.visitI64GeS() }
    case "i64.ge_u": return { return try $0.visitI64GeU() }
    case "f32.eq": return { return try $0.visitF32Eq() }
    case "f32.ne": return { return try $0.visitF32Ne() }
    case "f32.lt": return { return try $0.visitF32Lt() }
    case "f32.gt": return { return try $0.visitF32Gt() }
    case "f32.le": return { return try $0.visitF32Le() }
    case "f32.ge": return { return try $0.visitF32Ge() }
    case "f64.eq": return { return try $0.visitF64Eq() }
    case "f64.ne": return { return try $0.visitF64Ne() }
    case "f64.lt": return { return try $0.visitF64Lt() }
    case "f64.gt": return { return try $0.visitF64Gt() }
    case "f64.le": return { return try $0.visitF64Le() }
    case "f64.ge": return { return try $0.visitF64Ge() }
    case "i32.clz": return { return try $0.visitI32Clz() }
    case "i32.ctz": return { return try $0.visitI32Ctz() }
    case "i32.popcnt": return { return try $0.visitI32Popcnt() }
    case "i32.add": return { return try $0.visitI32Add() }
    case "i32.sub": return { return try $0.visitI32Sub() }
    case "i32.mul": return { return try $0.visitI32Mul() }
    case "i32.div_s": return { return try $0.visitI32DivS() }
    case "i32.div_u": return { return try $0.visitI32DivU() }
    case "i32.rem_s": return { return try $0.visitI32RemS() }
    case "i32.rem_u": return { return try $0.visitI32RemU() }
    case "i32.and": return { return try $0.visitI32And() }
    case "i32.or": return { return try $0.visitI32Or() }
    case "i32.xor": return { return try $0.visitI32Xor() }
    case "i32.shl": return { return try $0.visitI32Shl() }
    case "i32.shr_s": return { return try $0.visitI32ShrS() }
    case "i32.shr_u": return { return try $0.visitI32ShrU() }
    case "i32.rotl": return { return try $0.visitI32Rotl() }
    case "i32.rotr": return { return try $0.visitI32Rotr() }
    case "i64.clz": return { return try $0.visitI64Clz() }
    case "i64.ctz": return { return try $0.visitI64Ctz() }
    case "i64.popcnt": return { return try $0.visitI64Popcnt() }
    case "i64.add": return { return try $0.visitI64Add() }
    case "i64.sub": return { return try $0.visitI64Sub() }
    case "i64.mul": return { return try $0.visitI64Mul() }
    case "i64.div_s": return { return try $0.visitI64DivS() }
    case "i64.div_u": return { return try $0.visitI64DivU() }
    case "i64.rem_s": return { return try $0.visitI64RemS() }
    case "i64.rem_u": return { return try $0.visitI64RemU() }
    case "i64.and": return { return try $0.visitI64And() }
    case "i64.or": return { return try $0.visitI64Or() }
    case "i64.xor": return { return try $0.visitI64Xor() }
    case "i64.shl": return { return try $0.visitI64Shl() }
    case "i64.shr_s": return { return try $0.visitI64ShrS() }
    case "i64.shr_u": return { return try $0.visitI64ShrU() }
    case "i64.rotl": return { return try $0.visitI64Rotl() }
    case "i64.rotr": return { return try $0.visitI64Rotr() }
    case "f32.abs": return { return try $0.visitF32Abs() }
    case "f32.neg": return { return try $0.visitF32Neg() }
    case "f32.ceil": return { return try $0.visitF32Ceil() }
    case "f32.floor": return { return try $0.visitF32Floor() }
    case "f32.trunc": return { return try $0.visitF32Trunc() }
    case "f32.nearest": return { return try $0.visitF32Nearest() }
    case "f32.sqrt": return { return try $0.visitF32Sqrt() }
    case "f32.add": return { return try $0.visitF32Add() }
    case "f32.sub": return { return try $0.visitF32Sub() }
    case "f32.mul": return { return try $0.visitF32Mul() }
    case "f32.div": return { return try $0.visitF32Div() }
    case "f32.min": return { return try $0.visitF32Min() }
    case "f32.max": return { return try $0.visitF32Max() }
    case "f32.copysign": return { return try $0.visitF32Copysign() }
    case "f64.abs": return { return try $0.visitF64Abs() }
    case "f64.neg": return { return try $0.visitF64Neg() }
    case "f64.ceil": return { return try $0.visitF64Ceil() }
    case "f64.floor": return { return try $0.visitF64Floor() }
    case "f64.trunc": return { return try $0.visitF64Trunc() }
    case "f64.nearest": return { return try $0.visitF64Nearest() }
    case "f64.sqrt": return { return try $0.visitF64Sqrt() }
    case "f64.add": return { return try $0.visitF64Add() }
    case "f64.sub": return { return try $0.visitF64Sub() }
    case "f64.mul": return { return try $0.visitF64Mul() }
    case "f64.div": return { return try $0.visitF64Div() }
    case "f64.min": return { return try $0.visitF64Min() }
    case "f64.max": return { return try $0.visitF64Max() }
    case "f64.copysign": return { return try $0.visitF64Copysign() }
    case "i32.wrap_i64": return { return try $0.visitI32WrapI64() }
    case "i32.trunc_f32_s": return { return try $0.visitI32TruncF32S() }
    case "i32.trunc_f32_u": return { return try $0.visitI32TruncF32U() }
    case "i32.trunc_f64_s": return { return try $0.visitI32TruncF64S() }
    case "i32.trunc_f64_u": return { return try $0.visitI32TruncF64U() }
    case "i64.extend_i32_s": return { return try $0.visitI64ExtendI32S() }
    case "i64.extend_i32_u": return { return try $0.visitI64ExtendI32U() }
    case "i64.trunc_f32_s": return { return try $0.visitI64TruncF32S() }
    case "i64.trunc_f32_u": return { return try $0.visitI64TruncF32U() }
    case "i64.trunc_f64_s": return { return try $0.visitI64TruncF64S() }
    case "i64.trunc_f64_u": return { return try $0.visitI64TruncF64U() }
    case "f32.convert_i32_s": return { return try $0.visitF32ConvertI32S() }
    case "f32.convert_i32_u": return { return try $0.visitF32ConvertI32U() }
    case "f32.convert_i64_s": return { return try $0.visitF32ConvertI64S() }
    case "f32.convert_i64_u": return { return try $0.visitF32ConvertI64U() }
    case "f32.demote_f64": return { return try $0.visitF32DemoteF64() }
    case "f64.convert_i32_s": return { return try $0.visitF64ConvertI32S() }
    case "f64.convert_i32_u": return { return try $0.visitF64ConvertI32U() }
    case "f64.convert_i64_s": return { return try $0.visitF64ConvertI64S() }
    case "f64.convert_i64_u": return { return try $0.visitF64ConvertI64U() }
    case "f64.promote_f32": return { return try $0.visitF64PromoteF32() }
    case "i32.reinterpret_f32": return { return try $0.visitI32ReinterpretF32() }
    case "i64.reinterpret_f64": return { return try $0.visitI64ReinterpretF64() }
    case "f32.reinterpret_i32": return { return try $0.visitF32ReinterpretI32() }
    case "f64.reinterpret_i64": return { return try $0.visitF64ReinterpretI64() }
    case "i32.extend8_s": return { return try $0.visitI32Extend8S() }
    case "i32.extend16_s": return { return try $0.visitI32Extend16S() }
    case "i64.extend8_s": return { return try $0.visitI64Extend8S() }
    case "i64.extend16_s": return { return try $0.visitI64Extend16S() }
    case "i64.extend32_s": return { return try $0.visitI64Extend32S() }
    case "memory.init":
        let (dataIndex) = try expressionParser.visitMemoryInit(wat: &wat)
        return { return try $0.visitMemoryInit(dataIndex: dataIndex) }
    case "data.drop":
        let (dataIndex) = try expressionParser.visitDataDrop(wat: &wat)
        return { return try $0.visitDataDrop(dataIndex: dataIndex) }
    case "memory.copy":
        let (dstMem, srcMem) = try expressionParser.visitMemoryCopy(wat: &wat)
        return { return try $0.visitMemoryCopy(dstMem: dstMem, srcMem: srcMem) }
    case "memory.fill":
        let (memory) = try expressionParser.visitMemoryFill(wat: &wat)
        return { return try $0.visitMemoryFill(memory: memory) }
    case "table.init":
        let (elemIndex, table) = try expressionParser.visitTableInit(wat: &wat)
        return { return try $0.visitTableInit(elemIndex: elemIndex, table: table) }
    case "elem.drop":
        let (elemIndex) = try expressionParser.visitElemDrop(wat: &wat)
        return { return try $0.visitElemDrop(elemIndex: elemIndex) }
    case "table.copy":
        let (dstTable, srcTable) = try expressionParser.visitTableCopy(wat: &wat)
        return { return try $0.visitTableCopy(dstTable: dstTable, srcTable: srcTable) }
    case "table.fill":
        let (table) = try expressionParser.visitTableFill(wat: &wat)
        return { return try $0.visitTableFill(table: table) }
    case "table.get":
        let (table) = try expressionParser.visitTableGet(wat: &wat)
        return { return try $0.visitTableGet(table: table) }
    case "table.set":
        let (table) = try expressionParser.visitTableSet(wat: &wat)
        return { return try $0.visitTableSet(table: table) }
    case "table.grow":
        let (table) = try expressionParser.visitTableGrow(wat: &wat)
        return { return try $0.visitTableGrow(table: table) }
    case "table.size":
        let (table) = try expressionParser.visitTableSize(wat: &wat)
        return { return try $0.visitTableSize(table: table) }
    case "i32.trunc_sat_f32_s": return { return try $0.visitI32TruncSatF32S() }
    case "i32.trunc_sat_f32_u": return { return try $0.visitI32TruncSatF32U() }
    case "i32.trunc_sat_f64_s": return { return try $0.visitI32TruncSatF64S() }
    case "i32.trunc_sat_f64_u": return { return try $0.visitI32TruncSatF64U() }
    case "i64.trunc_sat_f32_s": return { return try $0.visitI64TruncSatF32S() }
    case "i64.trunc_sat_f32_u": return { return try $0.visitI64TruncSatF32U() }
    case "i64.trunc_sat_f64_s": return { return try $0.visitI64TruncSatF64S() }
    case "i64.trunc_sat_f64_u": return { return try $0.visitI64TruncSatF64U() }
    case "memory.atomic.notify":
        let (memarg) = try expressionParser.visitMemoryAtomicNotify(wat: &wat)
        return { return try $0.visitMemoryAtomicNotify(memarg: memarg) }
    case "memory.atomic.wait32":
        let (memarg) = try expressionParser.visitMemoryAtomicWait32(wat: &wat)
        return { return try $0.visitMemoryAtomicWait32(memarg: memarg) }
    case "memory.atomic.wait64":
        let (memarg) = try expressionParser.visitMemoryAtomicWait64(wat: &wat)
        return { return try $0.visitMemoryAtomicWait64(memarg: memarg) }
    case "atomic.fence": return { return try $0.visitAtomicFence() }
    case "i32.atomic.load":
        let (memarg) = try expressionParser.visitI32AtomicLoad(wat: &wat)
        return { return try $0.visitI32AtomicLoad(memarg: memarg) }
    case "i64.atomic.load":
        let (memarg) = try expressionParser.visitI64AtomicLoad(wat: &wat)
        return { return try $0.visitI64AtomicLoad(memarg: memarg) }
    case "i32.atomic.load8_u":
        let (memarg) = try expressionParser.visitI32AtomicLoad8U(wat: &wat)
        return { return try $0.visitI32AtomicLoad8U(memarg: memarg) }
    case "i32.atomic.load16_u":
        let (memarg) = try expressionParser.visitI32AtomicLoad16U(wat: &wat)
        return { return try $0.visitI32AtomicLoad16U(memarg: memarg) }
    case "i64.atomic.load8_u":
        let (memarg) = try expressionParser.visitI64AtomicLoad8U(wat: &wat)
        return { return try $0.visitI64AtomicLoad8U(memarg: memarg) }
    case "i64.atomic.load16_u":
        let (memarg) = try expressionParser.visitI64AtomicLoad16U(wat: &wat)
        return { return try $0.visitI64AtomicLoad16U(memarg: memarg) }
    case "i64.atomic.load32_u":
        let (memarg) = try expressionParser.visitI64AtomicLoad32U(wat: &wat)
        return { return try $0.visitI64AtomicLoad32U(memarg: memarg) }
    case "i32.atomic.store":
        let (memarg) = try expressionParser.visitI32AtomicStore(wat: &wat)
        return { return try $0.visitI32AtomicStore(memarg: memarg) }
    case "i64.atomic.store":
        let (memarg) = try expressionParser.visitI64AtomicStore(wat: &wat)
        return { return try $0.visitI64AtomicStore(memarg: memarg) }
    case "i32.atomic.store8":
        let (memarg) = try expressionParser.visitI32AtomicStore8(wat: &wat)
        return { return try $0.visitI32AtomicStore8(memarg: memarg) }
    case "i32.atomic.store16":
        let (memarg) = try expressionParser.visitI32AtomicStore16(wat: &wat)
        return { return try $0.visitI32AtomicStore16(memarg: memarg) }
    case "i64.atomic.store8":
        let (memarg) = try expressionParser.visitI64AtomicStore8(wat: &wat)
        return { return try $0.visitI64AtomicStore8(memarg: memarg) }
    case "i64.atomic.store16":
        let (memarg) = try expressionParser.visitI64AtomicStore16(wat: &wat)
        return { return try $0.visitI64AtomicStore16(memarg: memarg) }
    case "i64.atomic.store32":
        let (memarg) = try expressionParser.visitI64AtomicStore32(wat: &wat)
        return { return try $0.visitI64AtomicStore32(memarg: memarg) }
    case "i32.atomic.rmw.add":
        let (memarg) = try expressionParser.visitI32AtomicRmwAdd(wat: &wat)
        return { return try $0.visitI32AtomicRmwAdd(memarg: memarg) }
    case "i64.atomic.rmw.add":
        let (memarg) = try expressionParser.visitI64AtomicRmwAdd(wat: &wat)
        return { return try $0.visitI64AtomicRmwAdd(memarg: memarg) }
    case "i32.atomic.rmw8.add_u":
        let (memarg) = try expressionParser.visitI32AtomicRmw8AddU(wat: &wat)
        return { return try $0.visitI32AtomicRmw8AddU(memarg: memarg) }
    case "i32.atomic.rmw16.add_u":
        let (memarg) = try expressionParser.visitI32AtomicRmw16AddU(wat: &wat)
        return { return try $0.visitI32AtomicRmw16AddU(memarg: memarg) }
    case "i64.atomic.rmw8.add_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw8AddU(wat: &wat)
        return { return try $0.visitI64AtomicRmw8AddU(memarg: memarg) }
    case "i64.atomic.rmw16.add_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw16AddU(wat: &wat)
        return { return try $0.visitI64AtomicRmw16AddU(memarg: memarg) }
    case "i64.atomic.rmw32.add_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw32AddU(wat: &wat)
        return { return try $0.visitI64AtomicRmw32AddU(memarg: memarg) }
    case "i32.atomic.rmw.sub":
        let (memarg) = try expressionParser.visitI32AtomicRmwSub(wat: &wat)
        return { return try $0.visitI32AtomicRmwSub(memarg: memarg) }
    case "i64.atomic.rmw.sub":
        let (memarg) = try expressionParser.visitI64AtomicRmwSub(wat: &wat)
        return { return try $0.visitI64AtomicRmwSub(memarg: memarg) }
    case "i32.atomic.rmw8.sub_u":
        let (memarg) = try expressionParser.visitI32AtomicRmw8SubU(wat: &wat)
        return { return try $0.visitI32AtomicRmw8SubU(memarg: memarg) }
    case "i32.atomic.rmw16.sub_u":
        let (memarg) = try expressionParser.visitI32AtomicRmw16SubU(wat: &wat)
        return { return try $0.visitI32AtomicRmw16SubU(memarg: memarg) }
    case "i64.atomic.rmw8.sub_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw8SubU(wat: &wat)
        return { return try $0.visitI64AtomicRmw8SubU(memarg: memarg) }
    case "i64.atomic.rmw16.sub_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw16SubU(wat: &wat)
        return { return try $0.visitI64AtomicRmw16SubU(memarg: memarg) }
    case "i64.atomic.rmw32.sub_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw32SubU(wat: &wat)
        return { return try $0.visitI64AtomicRmw32SubU(memarg: memarg) }
    case "i32.atomic.rmw.and":
        let (memarg) = try expressionParser.visitI32AtomicRmwAnd(wat: &wat)
        return { return try $0.visitI32AtomicRmwAnd(memarg: memarg) }
    case "i64.atomic.rmw.and":
        let (memarg) = try expressionParser.visitI64AtomicRmwAnd(wat: &wat)
        return { return try $0.visitI64AtomicRmwAnd(memarg: memarg) }
    case "i32.atomic.rmw8.and_u":
        let (memarg) = try expressionParser.visitI32AtomicRmw8AndU(wat: &wat)
        return { return try $0.visitI32AtomicRmw8AndU(memarg: memarg) }
    case "i32.atomic.rmw16.and_u":
        let (memarg) = try expressionParser.visitI32AtomicRmw16AndU(wat: &wat)
        return { return try $0.visitI32AtomicRmw16AndU(memarg: memarg) }
    case "i64.atomic.rmw8.and_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw8AndU(wat: &wat)
        return { return try $0.visitI64AtomicRmw8AndU(memarg: memarg) }
    case "i64.atomic.rmw16.and_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw16AndU(wat: &wat)
        return { return try $0.visitI64AtomicRmw16AndU(memarg: memarg) }
    case "i64.atomic.rmw32.and_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw32AndU(wat: &wat)
        return { return try $0.visitI64AtomicRmw32AndU(memarg: memarg) }
    case "i32.atomic.rmw.or":
        let (memarg) = try expressionParser.visitI32AtomicRmwOr(wat: &wat)
        return { return try $0.visitI32AtomicRmwOr(memarg: memarg) }
    case "i64.atomic.rmw.or":
        let (memarg) = try expressionParser.visitI64AtomicRmwOr(wat: &wat)
        return { return try $0.visitI64AtomicRmwOr(memarg: memarg) }
    case "i32.atomic.rmw8.or_u":
        let (memarg) = try expressionParser.visitI32AtomicRmw8OrU(wat: &wat)
        return { return try $0.visitI32AtomicRmw8OrU(memarg: memarg) }
    case "i32.atomic.rmw16.or_u":
        let (memarg) = try expressionParser.visitI32AtomicRmw16OrU(wat: &wat)
        return { return try $0.visitI32AtomicRmw16OrU(memarg: memarg) }
    case "i64.atomic.rmw8.or_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw8OrU(wat: &wat)
        return { return try $0.visitI64AtomicRmw8OrU(memarg: memarg) }
    case "i64.atomic.rmw16.or_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw16OrU(wat: &wat)
        return { return try $0.visitI64AtomicRmw16OrU(memarg: memarg) }
    case "i64.atomic.rmw32.or_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw32OrU(wat: &wat)
        return { return try $0.visitI64AtomicRmw32OrU(memarg: memarg) }
    case "i32.atomic.rmw.xor":
        let (memarg) = try expressionParser.visitI32AtomicRmwXor(wat: &wat)
        return { return try $0.visitI32AtomicRmwXor(memarg: memarg) }
    case "i64.atomic.rmw.xor":
        let (memarg) = try expressionParser.visitI64AtomicRmwXor(wat: &wat)
        return { return try $0.visitI64AtomicRmwXor(memarg: memarg) }
    case "i32.atomic.rmw8.xor_u":
        let (memarg) = try expressionParser.visitI32AtomicRmw8XorU(wat: &wat)
        return { return try $0.visitI32AtomicRmw8XorU(memarg: memarg) }
    case "i32.atomic.rmw16.xor_u":
        let (memarg) = try expressionParser.visitI32AtomicRmw16XorU(wat: &wat)
        return { return try $0.visitI32AtomicRmw16XorU(memarg: memarg) }
    case "i64.atomic.rmw8.xor_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw8XorU(wat: &wat)
        return { return try $0.visitI64AtomicRmw8XorU(memarg: memarg) }
    case "i64.atomic.rmw16.xor_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw16XorU(wat: &wat)
        return { return try $0.visitI64AtomicRmw16XorU(memarg: memarg) }
    case "i64.atomic.rmw32.xor_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw32XorU(wat: &wat)
        return { return try $0.visitI64AtomicRmw32XorU(memarg: memarg) }
    case "i32.atomic.rmw.xchg":
        let (memarg) = try expressionParser.visitI32AtomicRmwXchg(wat: &wat)
        return { return try $0.visitI32AtomicRmwXchg(memarg: memarg) }
    case "i64.atomic.rmw.xchg":
        let (memarg) = try expressionParser.visitI64AtomicRmwXchg(wat: &wat)
        return { return try $0.visitI64AtomicRmwXchg(memarg: memarg) }
    case "i32.atomic.rmw8.xchg_u":
        let (memarg) = try expressionParser.visitI32AtomicRmw8XchgU(wat: &wat)
        return { return try $0.visitI32AtomicRmw8XchgU(memarg: memarg) }
    case "i32.atomic.rmw16.xchg_u":
        let (memarg) = try expressionParser.visitI32AtomicRmw16XchgU(wat: &wat)
        return { return try $0.visitI32AtomicRmw16XchgU(memarg: memarg) }
    case "i64.atomic.rmw8.xchg_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw8XchgU(wat: &wat)
        return { return try $0.visitI64AtomicRmw8XchgU(memarg: memarg) }
    case "i64.atomic.rmw16.xchg_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw16XchgU(wat: &wat)
        return { return try $0.visitI64AtomicRmw16XchgU(memarg: memarg) }
    case "i64.atomic.rmw32.xchg_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw32XchgU(wat: &wat)
        return { return try $0.visitI64AtomicRmw32XchgU(memarg: memarg) }
    case "i32.atomic.rmw.cmpxchg":
        let (memarg) = try expressionParser.visitI32AtomicRmwCmpxchg(wat: &wat)
        return { return try $0.visitI32AtomicRmwCmpxchg(memarg: memarg) }
    case "i64.atomic.rmw.cmpxchg":
        let (memarg) = try expressionParser.visitI64AtomicRmwCmpxchg(wat: &wat)
        return { return try $0.visitI64AtomicRmwCmpxchg(memarg: memarg) }
    case "i32.atomic.rmw8.cmpxchg_u":
        let (memarg) = try expressionParser.visitI32AtomicRmw8CmpxchgU(wat: &wat)
        return { return try $0.visitI32AtomicRmw8CmpxchgU(memarg: memarg) }
    case "i32.atomic.rmw16.cmpxchg_u":
        let (memarg) = try expressionParser.visitI32AtomicRmw16CmpxchgU(wat: &wat)
        return { return try $0.visitI32AtomicRmw16CmpxchgU(memarg: memarg) }
    case "i64.atomic.rmw8.cmpxchg_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw8CmpxchgU(wat: &wat)
        return { return try $0.visitI64AtomicRmw8CmpxchgU(memarg: memarg) }
    case "i64.atomic.rmw16.cmpxchg_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw16CmpxchgU(wat: &wat)
        return { return try $0.visitI64AtomicRmw16CmpxchgU(memarg: memarg) }
    case "i64.atomic.rmw32.cmpxchg_u":
        let (memarg) = try expressionParser.visitI64AtomicRmw32CmpxchgU(wat: &wat)
        return { return try $0.visitI64AtomicRmw32CmpxchgU(memarg: memarg) }
    default: return nil
    }
}
